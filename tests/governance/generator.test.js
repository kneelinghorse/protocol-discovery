/**
 * Tests for GovernanceGenerator
 */

const { GovernanceGenerator, SectionGenerators } = require('../../core/governance');
const { ProtocolGraph, NodeKind, EdgeKind } = require('../../core/graph');
const { OverrideEngine } = require('../../core/overrides');
const fs = require('fs-extra');
const path = require('path');
const os = require('os');

describe('GovernanceGenerator', () => {
  let graph;
  let overrideEngine;
  let generator;

  beforeEach(() => {
    // Create test graph with sample data
    graph = new ProtocolGraph();

    // Add sample nodes (URN format: urn:proto:<kind>:<authority>/<id>[@version])
    graph.addNode('urn:proto:api:test.com/users@1.0.0', NodeKind.API, {
      name: 'Users API',
      version: '1.0.0'
    });
    graph.addNode('urn:proto:data:test.com/user@1.0.0', NodeKind.DATA, {
      name: 'User Data',
      version: '1.0.0',
      fields: {
        email: { type: 'string', pii: true },
        name: { type: 'string', pii: true }
      }
    });
    graph.addNode('urn:proto:api:test.com/orders@1.0.0', NodeKind.API, {
      name: 'Orders API',
      version: '1.0.0'
    });

    // Add edges
    graph.addEdge(
      'urn:proto:api:test.com/users@1.0.0',
      EdgeKind.EXPOSES,
      'urn:proto:data:test.com/user@1.0.0'
    );
    graph.addEdge(
      'urn:proto:api:test.com/orders@1.0.0',
      EdgeKind.DEPENDS_ON,
      'urn:proto:api:test.com/users@1.0.0'
    );

    // Create override engine
    overrideEngine = new OverrideEngine();

    // Create generator
    generator = new GovernanceGenerator({
      graph,
      overrideEngine,
      manifests: []
    });
  });

  describe('generate()', () => {
    it('should generate complete GOVERNANCE.md', async () => {
      const content = await generator.generate();

      expect(content).toContain('# Protocol Governance');
      expect(content).toContain('## System Overview');
      expect(content).toContain('## Architecture');
      expect(content).toContain('## Data Privacy & PII Management');
      expect(content).toContain('## Change Management');
      expect(content).toContain('## Contribution Guidelines');
      expect(content).toContain('## Quality Metrics');
    });

    it('should include system statistics', async () => {
      const content = await generator.generate();

      expect(content).toContain('**Total Protocols**: 3');
      expect(content).toContain('**Protocol Relationships**: 2');
    });

    it('should support selective sections', async () => {
      const content = await generator.generate({
        sections: ['overview', 'architecture']
      });

      expect(content).toContain('## System Overview');
      expect(content).toContain('## Architecture');
      expect(content).not.toContain('## Data Privacy');
    });

    it('should support disabling diagrams', async () => {
      const content = await generator.generate({
        includeDiagrams: false
      });

      expect(content).not.toContain('```mermaid');
    });

    it('should include generation timestamp', async () => {
      const content = await generator.generate();

      expect(content).toMatch(/<!-- Auto-generated by GovernanceGenerator on \d{4}-\d{2}-\d{2}/);
    });
  });

  describe('generateToFile()', () => {
    let tempDir;

    beforeEach(async () => {
      tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'governance-test-'));
    });

    afterEach(async () => {
      await fs.remove(tempDir);
    });

    it('should write GOVERNANCE.md to file', async () => {
      const outputPath = path.join(tempDir, 'GOVERNANCE.md');
      const result = await generator.generateToFile(outputPath);

      expect(result.path).toBe(outputPath);
      expect(result.size).toBeGreaterThan(0);

      const content = await fs.readFile(outputPath, 'utf8');
      expect(content).toContain('# Protocol Governance');
    });

    it('should create directory if needed', async () => {
      const outputPath = path.join(tempDir, 'docs', 'GOVERNANCE.md');
      await generator.generateToFile(outputPath);

      expect(await fs.pathExists(outputPath)).toBe(true);
    });
  });

  describe('update()', () => {
    let tempDir;

    beforeEach(async () => {
      tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'governance-test-'));
    });

    afterEach(async () => {
      await fs.remove(tempDir);
    });

    it('should create new file if not exists', async () => {
      const outputPath = path.join(tempDir, 'GOVERNANCE.md');
      const result = await generator.update(outputPath);

      expect(result.path).toBe(outputPath);
      expect(await fs.pathExists(outputPath)).toBe(true);
    });

    it('should preserve custom sections', async () => {
      const outputPath = path.join(tempDir, 'GOVERNANCE.md');

      // Write initial file with custom section
      const initial = `# Governance

<!-- CUSTOM_START -->
## My Custom Section
This is custom content.
<!-- CUSTOM_END -->
`;
      await fs.writeFile(outputPath, initial, 'utf8');

      // Update
      await generator.update(outputPath);

      const updated = await fs.readFile(outputPath, 'utf8');
      expect(updated).toContain('My Custom Section');
      expect(updated).toContain('This is custom content');
    });
  });

  describe('SectionGenerators', () => {
    let sectionGen;

    beforeEach(() => {
      sectionGen = new SectionGenerators(graph, overrideEngine, []);
    });

    describe('generateOverview()', () => {
      it('should include system statistics', () => {
        const section = sectionGen.generateOverview();

        expect(section).toContain('# Protocol Governance');
        expect(section).toContain('## System Overview');
        expect(section).toContain('**Total Protocols**: 3');
      });

      it('should include protocol distribution', () => {
        const section = sectionGen.generateOverview();

        expect(section).toContain('**api**: 2');
        expect(section).toContain('**data**: 1');
      });
    });

    describe('generateArchitecture()', () => {
      it('should include dependency graph', () => {
        const section = sectionGen.generateArchitecture();

        expect(section).toContain('## Architecture');
        expect(section).toContain('### Protocol Dependency Graph');
      });

      it('should generate Mermaid diagram', () => {
        const section = sectionGen.generateArchitecture();

        expect(section).toContain('```mermaid');
        expect(section).toContain('graph TD');
        expect(section).toContain('```');
      });

      it('should detect circular dependencies', () => {
        // Create cycle
        graph.addEdge(
          'urn:proto:data:test.com/user@1.0.0',
          EdgeKind.DEPENDS_ON,
          'urn:proto:api:test.com/users@1.0.0'
        );

        const section = sectionGen.generateArchitecture();
        expect(section).toContain('**Circular Dependencies**:');
      });

      it('should show green check when no cycles', () => {
        const section = sectionGen.generateArchitecture();
        expect(section).toContain('**Circular Dependencies**: 0 âœ“');
      });
    });

    describe('generatePrivacy()', () => {
      it('should include PII statistics', () => {
        const section = sectionGen.generatePrivacy();

        expect(section).toContain('## Data Privacy & PII Management');
        expect(section).toContain('### PII Statistics');
      });

      it('should include privacy guidelines', () => {
        const section = sectionGen.generatePrivacy();

        expect(section).toContain('### Privacy Guidelines');
        expect(section).toContain('PII Detection');
        expect(section).toContain('Confidence Threshold');
      });

      it('should generate PII flow diagram', () => {
        const section = sectionGen.generatePrivacy();

        expect(section).toContain('### PII Flow Analysis');
        // May or may not have flow depending on test data
      });
    });

    describe('generateBreakingChanges()', () => {
      it('should include breaking change policy', () => {
        const section = sectionGen.generateBreakingChanges();

        expect(section).toContain('## Change Management');
        expect(section).toContain('### Breaking Change Policy');
        expect(section).toContain('Version Constraints');
      });

      it('should include impact assessment guide', () => {
        const section = sectionGen.generateBreakingChanges();

        expect(section).toContain('### Impact Assessment');
        expect(section).toContain('graph.assessRisk');
      });

      it('should include migration support', () => {
        const section = sectionGen.generateBreakingChanges();

        expect(section).toContain('### Migration Support');
        expect(section).toContain('Dual Versioning');
      });
    });

    describe('generateContributionGuidelines()', () => {
      it('should include contribution statistics', () => {
        const section = sectionGen.generateContributionGuidelines();

        expect(section).toContain('## Contribution Guidelines');
        expect(section).toContain('### Override Rule Contributions');
      });

      it('should include submission process', () => {
        const section = sectionGen.generateContributionGuidelines();

        expect(section).toContain('#### Submission Process');
        expect(section).toContain('createRule');
        expect(section).toContain('exportPack');
      });

      it('should include quality standards', () => {
        const section = sectionGen.generateContributionGuidelines();

        expect(section).toContain('#### Rule Quality Standards');
        expect(section).toContain('**Confidence**:');
        expect(section).toContain('**Testing**:');
      });

      it('should include review process', () => {
        const section = sectionGen.generateContributionGuidelines();

        expect(section).toContain('#### Review Process');
        expect(section).toContain('Automated Checks');
      });
    });

    describe('generateQualityMetrics()', () => {
      it('should include system health metrics', () => {
        const section = sectionGen.generateQualityMetrics();

        expect(section).toContain('## Quality Metrics');
        expect(section).toContain('### System Health');
      });

      it('should include override statistics table', () => {
        const section = sectionGen.generateQualityMetrics();

        expect(section).toContain('### Override Rule Statistics');
        expect(section).toContain('| Metric | Value |');
      });

      it('should include testing coverage', () => {
        const section = sectionGen.generateQualityMetrics();

        expect(section).toContain('### Testing Coverage');
        expect(section).toContain('90%+ coverage');
      });
    });

    describe('generateDependencyDiagram()', () => {
      it('should generate valid Mermaid syntax', () => {
        const diagram = sectionGen.generateDependencyDiagram();

        expect(diagram).toContain('```mermaid');
        expect(diagram).toContain('graph TD');
        expect(diagram).toContain('```');
      });

      it('should include nodes and edges', () => {
        const diagram = sectionGen.generateDependencyDiagram();

        expect(diagram).toMatch(/\[".*"\]/); // Node syntax
        expect(diagram).toMatch(/-->.*\|/); // Edge syntax
      });

      it('should handle empty graph', () => {
        const emptyGraph = new ProtocolGraph();
        const emptyGen = new SectionGenerators(emptyGraph, overrideEngine, []);
        const diagram = emptyGen.generateDependencyDiagram();

        expect(diagram).toContain('_No protocols in graph yet._');
      });

      it('should limit nodes for readability', () => {
        // Add 30 nodes
        for (let i = 0; i < 30; i++) {
          graph.addNode(`urn:proto:api:test.com/service${i}@1.0.0`, NodeKind.API, {});
        }

        const diagram = sectionGen.generateDependencyDiagram();
        const nodeCount = (diagram.match(/\["/g) || []).length;

        expect(nodeCount).toBeLessThanOrEqual(20); // Should limit to 20
      });
    });

    describe('generatePIIFlowDiagram()', () => {
      it('should generate Mermaid flow diagram', () => {
        const diagram = sectionGen.generatePIIFlowDiagram();

        // May be empty or have content depending on PII detection
        expect(typeof diagram).toBe('string');
      });

      it('should handle no PII', () => {
        const emptyGraph = new ProtocolGraph();
        const emptyGen = new SectionGenerators(emptyGraph, overrideEngine, []);
        const diagram = emptyGen.generatePIIFlowDiagram();

        expect(diagram).toContain('_No PII flow detected yet._');
      });
    });
  });

  describe('Mermaid diagram validation', () => {
    it('should generate valid Mermaid node IDs', () => {
      const sectionGen = new SectionGenerators(graph, overrideEngine, []);
      const sanitized = sectionGen._sanitizeNodeId('urn:proto:api:test.com/users@1.0.0');

      expect(sanitized).toMatch(/^[a-zA-Z0-9_]+$/);
      expect(sanitized).not.toContain(':');
      expect(sanitized).not.toContain('.');
    });

    it('should format node labels concisely', () => {
      const sectionGen = new SectionGenerators(graph, overrideEngine, []);
      const label = sectionGen._formatNodeLabel('urn:proto:api:test.com/users@1.0.0', {});

      expect(label.length).toBeLessThan(50);
      expect(label).toContain('users');
    });
  });

  describe('Error handling', () => {
    it('should handle missing graph gracefully', async () => {
      const gen = new GovernanceGenerator({
        graph: new ProtocolGraph(),
        overrideEngine
      });

      const content = await gen.generate();
      expect(content).toContain('# Protocol Governance');
    });

    it('should handle missing override engine', async () => {
      const gen = new GovernanceGenerator({
        graph,
        overrideEngine: new OverrideEngine()
      });

      const content = await gen.generate();
      expect(content).toContain('## Contribution Guidelines');
    });
  });
});
